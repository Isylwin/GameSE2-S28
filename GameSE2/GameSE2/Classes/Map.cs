//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace WinFormsGame.Classes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using MapClasses;

    public class Map
	{
        private Settings _settings;

		public virtual Cell[,] Cells { get; private set; }

		public Map(Settings settings)
		{
            this._settings = settings;

            Cells = new Cell[settings.HorizontalCells, settings.VerticalCells];

            for (int i = 0; i < settings.HorizontalCells; i++)
            {
                for (int j = 0; j < settings.VerticalCells; j++)
                {
                    Cells[i,j] = new Cell(new Location(i, j));
                    if (i == 0 || j == 0 || i == settings.HorizontalCells - 1 || j == settings.VerticalCells - 1) //Make borders a wall.
                        Cells[i, j].IsWall = true;
                }
            }
		}

		public virtual Path CalculatePath(Location startLoc, Location EndLoc)
		{
			throw new System.NotImplementedException();
		}

        /// <summary>
        /// Gets the cells within the view of a certain location.
        /// </summary>
        /// <param name="loc">Location which should be the center.</param>
        /// <returns>List with all the cells that are within view.</returns>
        public List<Cell> GetViewPort(Location loc) //Could return a 2D array with some trickery, doesn't seem necessary.
        {
            var returnValue = new List<Cell>();
            var xStart = loc.X > _settings.ViewWidth / 2 ? loc.X - _settings.ViewWidth / 2 : 0;
            var yStart = loc.Y > _settings.ViewHeight ? loc.Y - _settings.ViewHeight / 2 : 0;
            var xEnd = loc.X + _settings.ViewWidth / 2 < _settings.HorizontalCells ? loc.X + _settings.ViewWidth / 2 : _settings.HorizontalCells - 1;
            var yEnd = loc.Y + _settings.ViewHeight / 2 < _settings.HorizontalCells ? loc.Y + _settings.ViewHeight / 2 : _settings.VerticalCells - 1;

            for(int i = xStart; i <= xEnd; i++ )
            {
                for(int j = yStart; j <= yEnd; j++)
                {
                    returnValue.Add(Cells[i, j]);
                }
            }

            return returnValue;
        }

        public Location GetEmptyLocation(Random rnd)
        {
            Location returnLocation;
            int tries = 0;

            do
            {
                returnLocation = new Location(1, _settings.HorizontalCells, 1, _settings.VerticalCells, rnd);

                tries++;
                if(tries > _settings.HorizontalCells * _settings.VerticalCells)
                    throw new Exception("Cannot find empty location.");

            } while (Cells[returnLocation.X,returnLocation.Y].IsWall);

            return returnLocation;
        }
	}
}